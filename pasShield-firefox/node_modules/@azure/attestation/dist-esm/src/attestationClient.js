// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
import { GeneratedClient } from "./generated/generatedClient";
import { KnownDataType } from "./generated/models";
import { logger } from "./logger";
import { createSpan } from "./tracing";
import * as Mappers from "./generated/models/mappers";
import { SpanStatusCode } from "@azure/core-tracing";
import { createAttestationResponse } from "./models/attestationResponse";
import { TypeDeserializer } from "./utils/typeDeserializer";
import { isTokenCredential } from "@azure/core-auth";
import { bytesToString, stringToBytes } from "./utils/utf8";
import { _attestationResultFromGenerated } from "./models/attestationResult";
import { _attestationSignerFromGenerated } from "./models/attestationSigner";
import { AttestationTokenImpl } from "./models/attestationToken";
import { Uint8ArrayFromInput } from "./utils/buffer";
/**
 * Attestation Client class.
 *
 * The AttestationClient class enables access to the Attestation related APIs:
 *
 * - getOpenIdMetadata
 * - getAttestationSigners
 * - attestSgxEnclave
 * - attestOpenEnclave
 * - attestTpm
 */
export class AttestationClient {
    constructor(endpoint, credentialsOrOptions, clientOptions = {}) {
        let credentialScopes = undefined;
        let credential = undefined;
        let options = {};
        // If arg2 is defined, it's either a tokenCredential or it's a client options.
        if (credentialsOrOptions !== undefined) {
            if (isTokenCredential(credentialsOrOptions)) {
                credential = credentialsOrOptions;
                credentialScopes = ["https://attest.azure.net/.default"];
            }
            else {
                options = credentialsOrOptions;
            }
        }
        else if (clientOptions !== undefined) {
            options = clientOptions;
        }
        const internalPipelineOptions = Object.assign(Object.assign({}, options), {
            credentialScopes: credentialScopes,
            credential: credential,
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: ["x-ms-request-id", "x-ms-maa-service-version"]
            }
        });
        this._client = new GeneratedClient(endpoint, internalPipelineOptions);
        this._validationOptions = options.validationOptions;
    }
    /** Attests an OpenEnclave report generated from an SGX Enclave using the OpenEnclave SDK.
     *
     * @param report - An OpenEnclave report generated by an SGX enclave.
     * @param options - Operation options for the attestOpenEnclave API call.
     * @returns Returns an AttestationResponse whose body is an AttestationResult describing
     *    the claims returned by the attestation service.
     *
     * @throws {@link Error} if the `initTimeData` option and `initTimeJson` option is provided.
     * @throws {@link Error} if the `runTimeData` option and `runTimeJson` option is provided.
     * @throws {@link Error} if the `initTimeJson` option is provided and the value of `initTimeJson` is not JSON.
     * @throws {@link Error} if the `runTimeJson` option is provided and the value of `runTimeJson` is not JSON.
     */
    async attestOpenEnclave(report, options = {}) {
        var _a, _b, _c, _d;
        const { span, updatedOptions } = createSpan("AttestationClient-attestOpenEnclave", options);
        try {
            if (options.initTimeData !== undefined && options.initTimeJson !== undefined) {
                throw new Error("Cannot provide both initTimeData and initTimeJson.");
            }
            if (options.runTimeData !== undefined && options.runTimeJson !== undefined) {
                throw new Error("Cannot provide both runTimeData and runTimeJson.");
            }
            const initData = await Uint8ArrayFromInput((_a = options.initTimeData) !== null && _a !== void 0 ? _a : options.initTimeJson);
            const initTimeData = initData
                ? {
                    data: initData,
                    dataType: options.initTimeJson !== undefined ? KnownDataType.Json : KnownDataType.Binary
                }
                : undefined;
            const runData = await Uint8ArrayFromInput((_b = options.runTimeData) !== null && _b !== void 0 ? _b : options.runTimeJson);
            const runTimeData = runData
                ? {
                    data: runData,
                    dataType: options.runTimeJson !== undefined ? KnownDataType.Json : KnownDataType.Binary
                }
                : undefined;
            const attestationResponse = await this._client.attestation.attestOpenEnclave({
                report: await Uint8ArrayFromInput(report),
                initTimeData: initTimeData,
                runtimeData: runTimeData,
                draftPolicyForAttestation: (_c = options.draftPolicyForAttestation) !== null && _c !== void 0 ? _c : undefined
            }, updatedOptions);
            const token = new AttestationTokenImpl(attestationResponse.token);
            const problems = token.getTokenProblems(await this._signingKeys(), (_d = options.validationOptions) !== null && _d !== void 0 ? _d : this._validationOptions);
            if (problems.length) {
                throw new Error(problems.join(";"));
            }
            const attestationResult = TypeDeserializer.deserialize(token.getBody(), {
                GeneratedAttestationResult: Mappers.GeneratedAttestationResult,
                JsonWebKey: Mappers.JsonWebKey
            }, "GeneratedAttestationResult");
            return createAttestationResponse(token, _attestationResultFromGenerated(attestationResult));
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /** Attests a quote generated from SGX Enclave using the Intel SDK.
     *
     * @param quote - An SGX quote generated by an SGX enclave.
     * @param options - Operation options for the attestOpenEnclave API call.
     * @returns Returns an AttestationResponse whose body is an AttestationResult describing
     *    the claims returned by the attestation service.
     * @throws {@link Error} if the `initTimeData` option and `initTimeJson` option is provided.
     * @throws {@link Error} if the `runTimeData` option and `runTimeJson` option is provided.
     */
    async attestSgxEnclave(quote, options = {}) {
        var _a, _b, _c, _d;
        const { span, updatedOptions } = createSpan("AttestationClient-attestSgxEnclave", options);
        try {
            if (options.initTimeData !== undefined && options.initTimeJson !== undefined) {
                throw new Error("Cannot provide both initTimeData and initTimeJson.");
            }
            if (options.runTimeData !== undefined && options.runTimeJson !== undefined) {
                throw new Error("Cannot provide both runTimeData and runTimeJson.");
            }
            const initData = await Uint8ArrayFromInput((_a = options.initTimeData) !== null && _a !== void 0 ? _a : options.initTimeJson);
            const initTimeData = initData
                ? {
                    data: initData,
                    dataType: options.initTimeJson !== undefined ? KnownDataType.Json : KnownDataType.Binary
                }
                : undefined;
            const runData = await Uint8ArrayFromInput((_b = options.runTimeData) !== null && _b !== void 0 ? _b : options.runTimeJson);
            const runTimeData = runData
                ? {
                    data: runData,
                    dataType: options.runTimeJson !== undefined ? KnownDataType.Json : KnownDataType.Binary
                }
                : undefined;
            const attestationResponse = await this._client.attestation.attestSgxEnclave({
                quote: await Uint8ArrayFromInput(quote),
                initTimeData: initTimeData,
                runtimeData: runTimeData,
                draftPolicyForAttestation: (_c = options.draftPolicyForAttestation) !== null && _c !== void 0 ? _c : undefined
            }, updatedOptions);
            const token = new AttestationTokenImpl(attestationResponse.token);
            const problems = token.getTokenProblems(await this._signingKeys(), (_d = options.validationOptions) !== null && _d !== void 0 ? _d : this._validationOptions);
            if (problems.length) {
                throw new Error(problems.join(";"));
            }
            const attestationResult = TypeDeserializer.deserialize(token.getBody(), {
                GeneratedAttestationResult: Mappers.GeneratedAttestationResult,
                JsonWebKey: Mappers.JsonWebKey
            }, "GeneratedAttestationResult");
            return createAttestationResponse(token, _attestationResultFromGenerated(attestationResult));
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /** Attest a TPM based enclave.
  
     * See the  {@link https://docs.microsoft.com/en-us/azure/attestation/virtualization-based-security-protocol | TPM Attestation Protocol Reference} for more information.
     *
     * @param request - Incoming request to send to the TPM attestation service, Utf8 encoded.
     * @param options - Pipeline options for TPM attestation request.
     * @returns A structure containing the response from the TPM attestation, Utf8 encoded.
     *
     * @remarks
     *
     * The incoming requests to the TPM attestation API are stringified JSON objects.
     *
     * @example
     * For example, the initial call for a TPM attestation operation is:
     *
     * ```js
     * const encodedPayload = JSON.stringify({ payload: { type: "aikcert" } });
     * const result = await client.attestTpm(encodedPayload);
     * ```
     *
     * where stringToBytes converts the string to UTF8.
     *
     * Note that the attestTpm requires an attestation client which is configured with
     * authentication credentials.
     *
     */
    async attestTpm(request, options = {}) {
        const { span, updatedOptions } = createSpan("AttestationClient-attestSgxEnclave", options);
        try {
            const response = await this._client.attestation.attestTpm({ data: stringToBytes(request) }, updatedOptions);
            if (response.data) {
                return bytesToString(response.data);
            }
            else {
                throw Error("Internal error - response data cannot be undefined.");
            }
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns the list of attestation signers which can be used to sign attestation
     * service tokens.
     *
     * @param options - Client operation options.
     * @returns the set of AttestationSigners which may be used to sign attestation tokens.
     */
    async getAttestationSigners(options = {}) {
        var _a;
        const { span, updatedOptions } = createSpan("AttestationClient-getAttestationSigners", options);
        try {
            const signingCertificates = await this._client.signingCertificates.get(updatedOptions);
            const signers = new Array();
            (_a = signingCertificates.keys) === null || _a === void 0 ? void 0 : _a.forEach((element) => {
                signers.push(_attestationSignerFromGenerated(element));
            });
            return signers;
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    /**
     * Returns the OpenID Metadata discovery document for the attestation service instance.
     * @param options - Client operation options.
     * @returns The OpenID metadata discovery document for the attestation service.
     */
    async getOpenIdMetadata(options = {}) {
        const { span, updatedOptions } = createSpan("AttestationClient-getOpenIdMetadata", options);
        try {
            const configs = await this._client.metadataConfiguration.get(updatedOptions);
            return configs;
        }
        catch (e) {
            span.setStatus({ code: SpanStatusCode.ERROR, message: e.message });
            throw e;
        }
        finally {
            span.end();
        }
    }
    async _signingKeys() {
        var _a;
        if (this._signers !== undefined) {
            return this._signers;
        }
        const jwks = await this._client.signingCertificates.get();
        const signers = new Array();
        (_a = jwks.keys) === null || _a === void 0 ? void 0 : _a.forEach((element) => {
            signers.push(_attestationSignerFromGenerated(element));
        });
        this._signers = signers;
        return this._signers;
    }
}
//# sourceMappingURL=attestationClient.js.map